# Wrootz BRC-100 — Full Review Report v4

**Date:** 2026-02-17
**Review:** #6 (v4 of today's reviews)
**Reviewer:** Claude Sonnet 4.6
**Rating:** 8 / 10
**Previous:** Review #5 (2026-02-17, 44 findings, 7/10)

---

## Executive Summary

Two fix commits (`4bfbcdc`, `c54ff39`) were applied since Review #5, claiming to resolve all 44 reported findings. This review verifies those claims and identifies new issues.

**Result: 37 of 44 prior findings verified fixed.** The codebase has made significant strides — all 10 security findings are resolved, 9 of 10 bugs are fixed, most architecture and quality debt addressed. Test count grew from 64 to 89 with the addition of `wallet-utils.test.ts`.

Remaining concerns cluster around two themes:

1. **Insufficient recovery for fund-loss scenarios** — A1 (buy flow) and NB2 (lock flow) both have the same pattern: wallet operation succeeds, server record call fails, user loses funds with no persistent recovery path.
2. **Missing test coverage** — wallet adapter flows (Q2) and rate-limiting/idempotency logic (Q10) handle real money and remain completely untested.

---

## Pre-Review Baseline

| Check | Status |
|-------|--------|
| ESLint | ✅ Clean |
| TypeScript | ✅ Clean |
| Tests | ✅ 89/89 passing (5 test files) |

---

## Phase 1: Security Audit

### All 10 Prior Findings: FIXED

**S1 — txid SSRF (FIXED)**
`blockchain-verify.ts:70` now validates `/^[0-9a-f]{64}$/i` before URL construction. The prior length-only check allowed path traversal characters in the 64-char string.

**S2 — Seller address TOCTOU (FIXED)**
`getSellerAddress()` server action at `sales.ts:168-189` fetches the seller's wallet address server-side at the moment of purchase. The address is never included in HTML props or client-side state. This fully eliminates the payment redirection risk.

**S3 — Wallet session 30-day TTL (FIXED)**
`wallet-session.ts` now enforces a 2-hour cookie max-age and a 24-hour absolute maximum via `connectedAt` check. The `connectedAt` field that was previously stored but never enforced is now actively compared.

**S4 — Wallet session secret no minimum length (FIXED)**
`wallet-session.ts:30-32` now rejects secrets shorter than 32 characters, matching `session.ts`.

**S5 — Double-submit race (FIXED)**
`setLoading(true)` is now the first line of `handleBuy`, before any wallet connection checks.

**S6 — Rate limiting fails open (FIXED)**
`rate-limit-core.ts:70-71` now returns `{ allowed: false, remaining: 0, resetInSeconds: 60 }` for `auth:` and `strict:` prefixed rate limit keys when Redis is unavailable. Note: general tier still uses in-memory fallback (see A5).

**S7 — Untrusted proxy headers (FIXED)**
`extractClientIP` now only trusts `cf-connecting-ip` in production. The previous code trusted `x-forwarded-for` and `x-real-ip` unconditionally.

**S8 — Tolerance exploitable on small amounts (FIXED)**
Tolerance is now `max(100, amount * 0.005)` — percentage-based with a floor of 100 satoshis. This eliminates the fixed 100-sat tolerance representing 10%+ of dust-limit transactions.

**S9 — Console.error leaks txid (FIXED)**
Changed to `console.debug` which is not visible in production Node.js environments.

**S10 — ErrorBoundary logs in production (FIXED)**
Logging in `componentDidCatch` is now gated with `process.env.NODE_ENV === 'development'`.

### New Security Issues

**NS1 (High) — `getSellerAddress()` has no rate limit**

```typescript
// app/actions/posts/sales.ts:168
export async function getSellerAddress(postId: string): Promise<{ address?: string; error?: string }> {
  const session = await getSession()
  if (!session.userId) return { error: 'Not authenticated' }
  // No rate limit check here
  const post = await prisma.post.findUnique({ ... })
```

An authenticated user can call this in a tight loop across all post IDs to enumerate which posts have sellers with configured wallet addresses. This is low-impact for the data exposed but constitutes an authenticated enumeration vulnerability.

**Fix:** Add `checkGeneralRateLimit('getSellerAddress')` at the start of the function.

**NS2 (Medium) — Tolerance logging exposes satoshi amounts in production**

```typescript
// app/lib/blockchain-verify.ts:303
console.warn(`Lock amount tolerance match: expected ${expectedSatoshis}, got ${lockOutput.value}`)
```

This is an improvement over the previous version (which had no log), but in production this leaks exact transaction amounts to server logs. Logs are often accessible beyond the development team.

**Fix:** Gate with `if (process.env.NODE_ENV !== 'production')` or use a generic audit log entry.

---

## Phase 2: Bug Detection

### 9 of 10 Prior Findings: FIXED

**B1 — Stale `currentWallet` crash in SaleActions (FIXED)**

`connect()` now returns `{ address, wallet: adapter }`. The calling code captures this directly:
```typescript
const { wallet: connectedWallet } = await connect(walletType)
// connectedWallet is used below, not the stale state ref
```

**B2 — Same crash in LockForm (FIXED)**
Same fix applied in `LockForm.tsx:42-51`.

**B3 — SatsInput max=0 clamps input to 0 (FIXED)**
`SatsInput.tsx:49-52` now guards: only clamps when `max > 0`.

**B4 — Session crash without env vars (FIXED)**
Both session files fail immediately with a clear error message explaining how to generate a proper secret.

**B5 — LockForm NaN bypass (FIXED)**
`LockForm.tsx:59` now checks `isNaN(blocks)` before the range comparison.

**B6 — `fullyVerified` semantics (STILL OPEN)**

`route.ts:141-145`:
```typescript
fullyVerified:
  (!post.inscriptionTxid || inscriptionVerification?.verified) &&
  verifiedLocks.length === locksToVerify.length,
partialVerification: post.locks.length > MAX_LOCKS_TO_VERIFY,
```

For a post with 51 locks where all 50 verified pass: `fullyVerified = true` AND `partialVerification = true`. These are contradictory. The intent is clearly that `fullyVerified` means "everything was verified and passed" — which is false when only a subset was even checked.

**Fix:** `fullyVerified: post.locks.length <= MAX_LOCKS_TO_VERIFY && (!post.inscriptionTxid || inscriptionVerification?.verified) && verifiedLocks.length === locksToVerify.length`

**B7-B10 (FIXED)** — All verified fixed per plan.

### New Bugs

**NB1 (High) — LockForm missing mounted check after wallet operation**

`LockForm.tsx` uses `useMountedRef()` and guards state updates, but there is no check between `wallet.lockBSV()` completing and the subsequent `recordLock()` server call. If the user navigates away during the wallet signing dialog:
- The component unmounts
- `lockBSV()` eventually resolves
- `recordLock()` is called on server (correct)
- But subsequent state updates (`setTxStatus`, `setLoading`) fire on the unmounted component

`SaleActions.tsx` checks `if (!mountedRef.current) return` after every async operation. LockForm should do the same.

**NB2 (High) — LockForm has no recovery path for failed `recordLock()`**

This is the LockForm equivalent of A1 (SaleActions buy flow). The sequence:

1. User signs transaction in wallet → BSV is locked on-chain (irreversible)
2. `recordLock()` server call fails (network error, server crash, etc.)
3. Error state is shown, but the txid from `lockBSV()` result is not captured or displayed
4. User has no information to manually reconcile the lock

`SaleActions` partially addresses this by storing `completedTxid` in state. `LockForm` has no equivalent.

**Fix:** Capture `txid` from `lockBSV()` result before calling `recordLock()`. In the error path, display the txid so the user can reference it.

**NB3 (Medium) — `verifiedWrootz` uses stale database values**

`route.ts:109-115`:
```typescript
const verifiedWrootz = verifiedLocks.reduce((sum, lv) => {
  const lock = post.locks.find((l: { id: string }) => l.id === lv.lockId)
  return sum + (lock?.currentTu ?? 0)  // stale DB value
}, 0)
```

`currentTu` is a pre-computed field stored in the database. The on-chain verified amount is `lv.verification.onChainAmount`. The two can diverge if the lock's on-chain amount differs from the cached value. The verification endpoint exists precisely to compare on-chain reality against the database — using the DB value here defeats its purpose.

**Fix:** Use `lv.verification.onChainAmount ?? lock?.satoshis ?? 0` (on-chain first, DB satoshis as fallback, never stale `currentTu`).

---

## Phase 3: Architecture Review

### 8 of 10 Prior Findings: FIXED, 2 Partially Open

**A1 — Buy flow: payment sent, server confirmation fails (PARTIALLY FIXED)**

`SaleActions.tsx` now captures the `txid` from `sendBSV()` into `completedTxid` state and displays it in the error message. This is a meaningful improvement — users at least have the txid to reference.

However, the txid lives in React state, which is lost on page refresh. A user who navigates away (or refreshes) after this error loses all recovery information.

**Remaining gap:** Persist `completedTxid` to `localStorage` (keyed by `postId`) immediately after `sendBSV()` succeeds. Clear it when `buyPost()` confirms. On component mount, check for a stale `completedTxid` in storage and display a recovery banner.

**A2, A3, A4, A6, A7, A10 (FIXED)** — All verified.

**A5 — In-memory stores fail silently (PARTIALLY FIXED)**

Auth and strict-tier rate limits now fail-closed in production. However, the general tier (used for non-critical operations) still falls back to a per-instance in-memory `Map`. In a serverless deployment with multiple instances, rate limit state is not shared — the in-memory store is effectively useless.

This is lower risk than before (financial operations use strict tier), but any operation using the general tier can be bypassed by distributing requests across instances.

**A8 — N/A** — Confirmed not a password-based auth system.

**A9 — Tolerance logging (PARTIALLY FIXED)**

`console.warn` added at `blockchain-verify.ts:303`. The logging exists but exposes satoshi amounts in production (see NS2). The fix is present but needs the production guard.

**New Architecture Issue:**

**NA1 (Low) — Duplicate cached query exports**

`queries.ts:570-594` exports `getTopTagsCached`, `getTopLockersCached`, `getRecentActivityCached` using `unstable_cache`. `queries-cached.ts` also exports these three functions, wrapping the same underlying functions with identical cache keys.

`index.ts` re-exports only from `queries-cached.ts` (the canonical path), so `import { getTopTagsCached } from '@/app/actions/posts'` works correctly.

The problem is latent: any code that imports directly from `queries.ts` (e.g., during refactoring or by a new developer) gets a different `unstable_cache` instance with the same cache keys — potentially creating a two-instance cache split where invalidation of one doesn't affect the other.

**Fix:** Delete the three `*Cached` exports from `queries.ts`. They belong exclusively in `queries-cached.ts`.

---

## Phase 4: Code Quality

### 14 of 16 Prior Findings: FIXED

**Q1 — Wallet adapter duplication (FIXED)**

`wallet-utils.ts` exports 6 shared utilities: `withTimeout`, `pushData`, `hash160`, `decodeBase58Check`, `createP2PKHLockingScript`, `buildInscriptionScript`. Both `brc100-adapter.ts` and `simplysats-adapter.ts` import from it. ~150 lines of duplicated cryptographic code eliminated.

**Q2 — Zero wallet adapter tests (STILL OPEN)**

`wallet-utils.test.ts` adds 24 tests covering the pure utility functions. This is good progress but the adapter logic itself — connection flows, transaction construction, balance retrieval, error handling — remains untested. The adapters contain ~1500 lines handling real BSV transactions.

**Q4, Q5, Q6, Q7, Q8, Q9, Q12, Q13-16 (FIXED)** — All verified.

**Q10 — No rate-limit-core tests (STILL OPEN)**

`rate-limit-core.ts` implements the sliding window algorithm, fail-closed behavior, IP extraction logic, and in-memory cleanup. `idempotency.ts` implements distributed locking with Redis. Neither has test coverage. The in-memory fallback behavior (used in development and as a fallback) is particularly important to test since it's hard to verify correctness from code review alone.

**Q11 — Aria-live regions (PARTIALLY FIXED)**

Transaction forms in `LockForm.tsx` and `SaleActions.tsx` now have proper `role="alert"` and `aria-live="polite"` attributes. The admin page status messages at `app/admin/page.tsx:159-172` still lack these attributes.

### New Quality Issues

**NQ1 (Low) — Admin page missing mountedRef**

`app/admin/page.tsx:84-107`: `loadData()` is an async function called in `useEffect`. It calls `setUsers()`, `setPosts()`, `setLocks()`, `setCurrentBlock()` without checking if the component is still mounted. If the admin navigates away during data load, React will log an update-on-unmounted-component warning.

**Fix:** Add `useMountedRef()` from `app/hooks/useMountedRef.ts` (already used in LockForm and SaleActions).

**NQ2 (Low) — Unbounded userAgent storage**

`app/actions/admin.ts:49`: The raw `userAgent` header is written to the audit log without truncation. A malicious admin (or compromised account) could write an arbitrarily large string to the audit log table.

**Fix:** `const safeUserAgent = (headers().get('user-agent') ?? 'unknown').substring(0, 1024)`

**NQ3 (Low) — FeedClient string-join change detection**

`app/components/FeedClient.tsx:40`: Post ID deduplication uses `posts.map(p => p.id).join(',')` to generate a dependency key. With UUIDs this is safe in practice (no commas), but it's a pattern that doesn't scale well and could fail silently if ID format changes.

**Fix:** Use `new Set(posts.map(p => p.id))` comparison or a hash.

---

## What Went Well

The two fix commits are high-quality work. Specific callouts:

1. **Safe listener swap in WalletProvider** — The `connect()` function registers new event listeners into a temporary array first, then swaps out old ones only after both registrations succeed. If either registration throws, old listeners remain intact. This is correct, defensive code.

2. **wallet-utils.ts extraction** — The six shared cryptographic utilities are well-tested (24 tests) and properly typed. The extraction reduces ~150 lines of duplicated code.

3. **Idempotency module** — The upgrade to Redis-backed distributed locking with proper TTL, cleanup timer, and `.unref()` is production-quality.

4. **Rate limit IP extraction** — The production-only Cloudflare header trust is correct. Many codebases get this wrong by trusting `x-forwarded-for` everywhere.

5. **TOCTOU fix (S2)** — Moving seller address lookup server-side is the architecturally correct fix, not just a band-aid.

---

## Summary

| Category | Total Issues | Fixed | Critical | High | Medium | Low |
|----------|-------------|-------|---------|------|--------|-----|
| Security | 12 | 10 | 0 | 1 | 1 | 0 |
| Bugs | 13 | 9 | 1 (B6) | 2 (NB1, NB2) | 1 (NB3) | 0 |
| Architecture | 11 | 8 | 0 | 1 (A1) | 1 (A5) | 1 (NA1) |
| Quality | 19 | 14 | 0 | 1 (Q2) | 2 (Q10, Q11) | 3 (NQ1-3) |
| **Total** | **55** | **41** | **1** | **5** | **5** | **4** |

**Overall: 8/10** — Substantial improvement. The remaining critical issue (B6) is a quick fix. The high-priority items cluster around fund-loss recovery (A1, NB1, NB2) — important for a financial application, but none are showstoppers that would cause immediate data loss in the happy path. Test coverage for wallet adapters and rate limiting should be planned for the sprint after next.
