# Review #11 — UX/UI Polish & Frontend Stability

**Date:** 2026-02-17
**Rating:** 8.0 / 10
**Focus:** UX polish, accessibility, frontend stability
**Reviewer:** Claude Opus 4.6

---

## Pre-Review Status

| Check | Result |
|-------|--------|
| ESLint | Clean — no warnings or errors |
| TypeScript | Clean — no type errors |
| Tests | 236/236 passing |

All toolchain checks pass. This review narrows scope to UX/UI polish, accessibility compliance, and frontend runtime stability. Security posture is inherited from prior reviews (15/15 historical issues resolved).

---

## Executive Summary

The Wrootz BRC-100 codebase has strong security (15/15 historical issues resolved) and solid functional correctness. This review focused specifically on UX/UI polish and frontend stability, revealing **27 new issues** across four phases.

Three critical CSS variable bugs cause invisible UI elements in production — the `--error`, `--success`, and `--primary-dark` variables are referenced in component code but never defined in `globals.css`. A compound SWR bug causes infinite retry loops on expired sessions because the error object never surfaces HTTP status codes that the retry handler checks for. Multiple accessibility gaps exist across modal dialogs, filter buttons, and interactive elements. Architecture gaps include no SEO metadata on dynamic routes and missing `loading.tsx` / `error.tsx` boundaries for most routes.

**27 total findings:** 3 Critical, 4 High (bugs), 6 High (architecture/quality), 8 Medium, 6 Low.

---

## Phase 1: Security

No new security issues found. Security posture from prior reviews remains strong with all 15 historical issues resolved. The rate limiter, wallet session TTL, cron endpoint authentication, and input sanitization all remain correctly implemented per Reviews #5 through #9.

---

## Phase 2: Bug Detection (10 issues found)

---

### B-11-1 CRITICAL: `--error` CSS variable undefined

**File:** `app/components/EditProfileButton.tsx` — lines 209 and 278

**Description:** The component uses `text-[var(--error)]` to style the "Remove" button text and error messages. However, `--error` is never defined in `globals.css`. The correct variable name is `--danger`.

**Code:**

```tsx
// EditProfileButton.tsx, line 209
<button className="text-[var(--error)] hover:underline">Remove</button>

// EditProfileButton.tsx, line 278
<p className="text-[var(--error)] text-sm">{error}</p>
```

**Impact:** The "Remove" button and any error messages in the edit-profile modal render with no color. On dark backgrounds, the text becomes completely invisible. Users cannot see the remove action or form validation errors.

**Fix:** Replace `var(--error)` with `var(--danger)` in both locations. The `--danger` variable is already defined in `globals.css` for both light and dark themes.

```tsx
// Line 209
<button className="text-[var(--danger)] hover:underline">Remove</button>

// Line 278
<p className="text-[var(--danger)] text-sm">{error}</p>
```

---

### B-11-2 CRITICAL: `--success` CSS variable undefined

**Files:**
- `app/components/WalletButton.tsx` — lines 93, 119, 226
- `app/components/MyLocks.tsx` — lines 124, 153, 172, 181
- `app/components/TransactionHistory.tsx` — line 43

**Description:** Multiple components reference `var(--success)` which is never defined in `globals.css`. This affects a wide surface area of success-state UI.

**Affected elements:**
- WalletButton: connected-wallet indicator dot, "Connected" text, wallet checkmark icon
- MyLocks: unlock success banner, lock status badges for "active" and "completed" states
- TransactionHistory: confirmed transaction status badge

**Code (representative samples):**

```tsx
// WalletButton.tsx, line 93
<span className="w-2 h-2 rounded-full bg-[var(--success)]" />

// MyLocks.tsx, line 124
<div className="bg-[var(--success)]/10 text-[var(--success)] px-3 py-2 rounded">
  Lock successfully released
</div>

// TransactionHistory.tsx, line 43
<span className="text-[var(--success)]">Confirmed</span>
```

**Impact:** All success indicators render with no color. The connected-wallet dot is invisible, "Confirmed" transaction badges have no color, and lock status badges are unreadable. This is a production-visible bug affecting core user feedback loops.

**Fix:** Add `--success` to both theme blocks in `globals.css`:

```css
:root {
  /* ... existing variables ... */
  --success: var(--accent);
}

[data-theme="dark"] {
  /* ... existing variables ... */
  --success: var(--accent);
}
```

Alternatively, define a distinct green value if the accent color is not semantically appropriate for success states.

---

### B-11-3 CRITICAL: `--primary-dark` CSS variable undefined

**File:** `app/components/FeedClient.tsx` — line 82

**Description:** The "New activity - click to refresh" notification banner uses `hover:bg-[var(--primary-dark)]` for its hover state. This variable does not exist — the correct variable is `--primary-hover`.

**Code:**

```tsx
// FeedClient.tsx, line 82
<button
  onClick={handleRefresh}
  className="bg-[var(--primary)] hover:bg-[var(--primary-dark)] text-white px-4 py-2 rounded-full"
>
  New activity - click to refresh
</button>
```

**Impact:** The hover state on this button has no visual effect. Users get no feedback when hovering over the refresh notification, which reduces perceived interactivity.

**Fix:** Replace `var(--primary-dark)` with `var(--primary-hover)`:

```tsx
className="bg-[var(--primary)] hover:bg-[var(--primary-hover)] text-white px-4 py-2 rounded-full"
```

---

### B-11-4 HIGH: SWR infinite retry on expired sessions

**File:** `app/hooks/useAppData.ts` — lines 12-19 and 174-185

**Description:** This is a compound bug with three interacting failures:

1. **The SWR fetcher throws a generic error:** `throw new Error('An error occurred while fetching data')` — the HTTP status code is never included in the error message or attached as a property.

2. **The retry handler checks for status in the message:** `shouldRetryOnError` inspects `error.message.includes('401')`, which can never match because step 1 never puts `401` in the message.

3. **The swrConfig object is exported but never consumed:** The config is defined and exported, but no `<SWRConfig value={swrConfig}>` provider wraps the application. Even if the retry logic were correct, it would never execute.

**Code:**

```typescript
// useAppData.ts, lines 12-19 — fetcher
const fetcher = async (url: string) => {
  const res = await fetch(url)
  if (!res.ok) {
    throw new Error('An error occurred while fetching data')
    // ^ status code is lost here
  }
  return res.json()
}

// useAppData.ts, lines 174-185 — retry config
export const swrConfig = {
  shouldRetryOnError: (error: Error) => {
    if (error.message.includes('401')) {
      // ^ This can never match — the fetcher never includes '401'
      return false
    }
    return true
  },
  errorRetryCount: 3,
}
```

**Impact:** When sessions expire and the API returns 401, SWR retries indefinitely (the default `errorRetryCount` of 3 is in the unused config). This causes:
- Sustained load on the server from all active clients
- Console floods with failed fetch errors
- No session-expiry redirect or re-auth prompt for the user

**Fix (three parts):**

```typescript
// 1. Surface status in the error
class FetchError extends Error {
  status: number
  constructor(message: string, status: number) {
    super(message)
    this.status = status
  }
}

const fetcher = async (url: string) => {
  const res = await fetch(url)
  if (!res.ok) {
    throw new FetchError(`Fetch error: ${res.status}`, res.status)
  }
  return res.json()
}

// 2. Fix the retry handler
export const swrConfig = {
  shouldRetryOnError: (error: Error) => {
    if (error instanceof FetchError && (error.status === 401 || error.status === 403)) {
      return false
    }
    return true
  },
  errorRetryCount: 3,
}

// 3. Wire the config via SWRConfig provider in layout.tsx or a providers component
<SWRConfig value={swrConfig}>
  {children}
</SWRConfig>
```

---

### B-11-5 HIGH: ReplyForm silently drops errors

**File:** `app/components/ReplyForm.tsx` — lines 33-36

**Description:** The catch block in the reply submission handler only resets the loading state. It never sets an error message, so the user receives no feedback when a reply fails to post.

**Code:**

```tsx
// ReplyForm.tsx, lines 33-36
} catch (err) {
  console.error('Failed to post reply:', err)
  setLoading(false)
  // Missing: setError('Failed to post reply. Please try again.')
}
```

**Impact:** Network errors, server errors, or rate-limit rejections leave the form in its default state with no error message. The user's reply text is still in the textarea, but they have no indication that it failed to submit. They may assume it posted and navigate away.

**Fix:**

```tsx
} catch (err) {
  console.error('Failed to post reply:', err)
  setError('Failed to post reply. Please try again.')
  setLoading(false)
}
```

---

### B-11-6 HIGH: WalletButton setTimeout not cleared on unmount

**File:** `app/components/WalletButton.tsx` — line 64

**Description:** After copying the wallet address, a `setTimeout` resets the "copied" state after 2 seconds. The timer reference is not stored, and there is no cleanup on unmount.

**Code:**

```tsx
// WalletButton.tsx, line 64
const handleCopy = () => {
  navigator.clipboard.writeText(address)
  setCopied(true)
  setTimeout(() => setCopied(false), 2000)
  // ^ Timer not stored, not cleaned up on unmount
}
```

**Impact:** If the user navigates away within 2 seconds of copying, `setCopied(false)` fires on an unmounted component. In React 18 strict mode this produces a console warning; in some edge cases it can cause state corruption in the component tree.

**Fix:**

```tsx
const timerRef = useRef<NodeJS.Timeout | null>(null)

useEffect(() => {
  return () => {
    if (timerRef.current) clearTimeout(timerRef.current)
  }
}, [])

const handleCopy = () => {
  navigator.clipboard.writeText(address)
  setCopied(true)
  timerRef.current = setTimeout(() => setCopied(false), 2000)
}
```

---

### B-11-7 MEDIUM: VerificationBadge missing mountedRef guard

**File:** `app/components/VerificationBadge.tsx` — lines 34-49

**Description:** The `verify()` async call in useEffect sets state after resolution, but there is no mountedRef guard to prevent setState on an unmounted component.

**Impact:** If the component unmounts before the verification API call completes (e.g., the user scrolls past a post quickly), setState fires on an unmounted component.

**Fix:** Add a `mountedRef` or use the cleanup function pattern:

```tsx
useEffect(() => {
  let mounted = true
  verify(address).then((result) => {
    if (mounted) {
      setVerified(result)
      setLoading(false)
    }
  })
  return () => { mounted = false }
}, [address])
```

---

### B-11-8 MEDIUM: PostPageClient missing mountedRef in fetchData

**File:** `app/post/[id]/PostPageClient.tsx` — lines 60-95

**Description:** The `fetchData` function contains seven setState calls after an async fetch, none of which are guarded by a mountedRef check.

**Impact:** Navigating away from a post page during data fetch triggers multiple setState calls on an unmounted component.

**Fix:** Apply the same `mounted` flag pattern as B-11-7 to the fetchData function and its callers.

---

### B-11-9 MEDIUM: HidePostButton silently swallows errors

**File:** `app/components/HidePostButton.tsx` — lines 28-30

**Description:** Errors from `hidePost()` / `unhidePost()` are caught and logged to console.error but never surfaced to the user.

**Impact:** If the hide/unhide action fails (network error, rate limit, server error), the button returns to its original state with no feedback. The user may assume the action succeeded.

**Fix:** Add error state and a brief inline error display:

```tsx
const [error, setError] = useState<string | null>(null)

// In catch block:
setError('Action failed. Try again.')
setTimeout(() => setError(null), 3000)
```

---

### B-11-10 MEDIUM: ProfilePageClient polls without visibility check

**File:** `app/profile/ProfilePageClient.tsx` — lines 94-97

**Description:** The profile page polls for data every 5 seconds unconditionally. Unlike `PostPageClient`, which pauses polling when the tab is hidden via a `visibilitychange` listener, the profile page continues polling in background tabs.

**Impact:** Users who open multiple profile tabs accumulate unnecessary server load. On mobile browsers, this can also prevent the tab from being properly suspended.

**Fix:** Add a `visibilitychange` listener to pause and resume the polling interval, mirroring the pattern already used in `PostPageClient`:

```tsx
useEffect(() => {
  const handleVisibility = () => {
    if (document.hidden) {
      clearInterval(intervalRef.current)
    } else {
      intervalRef.current = setInterval(fetchData, 5000)
    }
  }
  document.addEventListener('visibilitychange', handleVisibility)
  return () => document.removeEventListener('visibilitychange', handleVisibility)
}, [])
```

---

## Phase 3: Architecture Review (6 issues found)

---

### A-11-1 HIGH: ErrorBoundary implemented but never used

**File:** `app/components/ErrorBoundary.tsx` — zero import sites across the codebase

**Description:** A well-implemented React error boundary component exists in the codebase, but it is never imported or rendered anywhere. The high-risk async widgets — LockForm, TipForm, SaleActions, VerificationBadge, and MyLocks — all run without error boundaries.

**Impact:** Any unhandled runtime error in these widgets crashes the entire page rather than being contained to the failing widget. This is especially problematic for LockForm and TipForm, which involve financial operations and network calls.

**Fix:** Wrap each high-risk widget in `PostPageClient.tsx` and `ProfilePageClient.tsx`:

```tsx
import { ErrorBoundary } from '@/components/ErrorBoundary'

<ErrorBoundary fallback={<p>Something went wrong. Please refresh.</p>}>
  <LockForm postId={post.id} />
</ErrorBoundary>
```

---

### A-11-2 HIGH: No generateMetadata on dynamic routes

**Files:**
- `app/post/[id]/page.tsx`
- `app/profile/[username]/page.tsx`
- `app/tag/[tag]/page.tsx`

**Description:** None of the dynamic routes export a `generateMetadata` function. There are no page-level titles, descriptions, or Open Graph tags for individual posts, profiles, or tag pages.

**Impact:** Critical for a content-sharing platform. Shared links on social media render with the generic site title and no preview. Search engines cannot index individual post or profile pages with meaningful titles. This significantly hurts discoverability and engagement.

**Fix:** Add `generateMetadata` to each dynamic route:

```typescript
// app/post/[id]/page.tsx
export async function generateMetadata({ params }: { params: { id: string } }) {
  const post = await getPost(params.id)
  return {
    title: post ? `${post.content.slice(0, 60)}... — Wrootz` : 'Post — Wrootz',
    description: post?.content.slice(0, 160),
    openGraph: {
      title: post?.content.slice(0, 60),
      description: post?.content.slice(0, 160),
      type: 'article',
    },
  }
}
```

---

### A-11-3 HIGH: Missing loading.tsx for 9+ routes

**Description:** Only the root route and `post/[id]` have `loading.tsx` skeletons. The following routes show a blank white page during data fetch:
- `profile/[username]`
- `tag/[tag]`
- `notifications`
- `create`
- `admin`
- `settings`
- And several others

**Impact:** Users see a blank page during navigation, which feels broken. On slower connections this can last several seconds. The perceived performance is significantly worse than it needs to be.

**Fix:** Add `loading.tsx` to the highest-traffic routes first — `profile/[username]`, `tag/[tag]`, and `notifications`. Each should render a skeleton that matches the layout of the corresponding page component.

---

### A-11-4 HIGH: Missing error.tsx for most routes

**Description:** Only the root route and `post/[id]` have route-level `error.tsx` boundaries. Errors in all other routes bubble up to the global error boundary, which provides a generic "Something went wrong" message with no route-specific recovery options.

**Impact:** Users on the profile page, tag page, or notifications page who encounter a server error see a full-page error with no "try again" affordance specific to that route. The only recovery is a full page refresh or navigation.

**Fix:** Add `error.tsx` to the main content routes (`profile/[username]`, `tag/[tag]`, `notifications`) with a "Try again" button that calls `reset()`:

```tsx
'use client'

export default function Error({ error, reset }: { error: Error; reset: () => void }) {
  return (
    <div className="flex flex-col items-center gap-4 py-12">
      <h2>Something went wrong</h2>
      <button onClick={reset} className="btn-primary">Try again</button>
    </div>
  )
}
```

---

### A-11-5 MEDIUM: Loading skeleton breakpoint mismatch

**Description:** The existing `loading.tsx` files use `lg:` breakpoints (1024px) for layout shifts, while the corresponding `page.tsx` files use `md:` breakpoints (768px). This creates a layout mismatch on viewports between 768px and 1023px.

**Impact:** On tablet-sized viewports, the loading skeleton renders in a single-column layout while the actual page content renders in a two-column layout. This causes a visible layout shift when loading completes, which harms perceived quality.

**Fix:** Align `loading.tsx` to use the same `md:` breakpoints as `page.tsx`.

---

### A-11-6 MEDIUM: Dark mode FOUC (Flash of Unstyled Content)

**Description:** The dark/light theme is applied via a `useEffect` hook after the first render. On page load, the browser renders with the default light theme CSS variables, then switches to dark mode once the effect runs. This causes a visible flash.

**Impact:** Users with dark mode preference see a brief flash of light theme on every page load or navigation. This is visually jarring and feels unpolished.

**Fix:** Add a blocking inline script in the `<head>` (via Next.js `app/layout.tsx`) that reads the theme preference and sets `data-theme` before the first paint:

```tsx
// In layout.tsx <head>
<script dangerouslySetInnerHTML={{ __html: `
  (function() {
    var theme = localStorage.getItem('theme') ||
      (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    document.documentElement.setAttribute('data-theme', theme);
  })();
` }} />
```

---

## Phase 4: Code Quality / UX Polish (11 issues found)

---

### Q-11-1 HIGH: EditProfileButton modal missing ARIA dialog semantics

**File:** `app/components/EditProfileButton.tsx` — lines 168-300

**Description:** The edit-profile modal is implemented as a conditional div overlay but lacks fundamental ARIA dialog requirements:
- No `role="dialog"`
- No `aria-modal="true"`
- No `aria-labelledby` pointing to the modal title
- No focus trap (Tab can reach elements behind the backdrop)
- No Escape key handler to close
- No backdrop click-to-close handler

**Impact:** The modal is completely inaccessible to screen reader users. Keyboard users can tab behind the modal into invisible content. This fails WCAG 2.1 SC 4.1.2 (Name, Role, Value) and SC 2.1.1 (Keyboard).

**Fix:** Full ARIA dialog implementation:

```tsx
<div
  role="dialog"
  aria-modal="true"
  aria-labelledby="edit-profile-title"
  onKeyDown={(e) => { if (e.key === 'Escape') onClose() }}
  onClick={(e) => { if (e.target === e.currentTarget) onClose() }}
>
  <h2 id="edit-profile-title">Edit Profile</h2>
  {/* ... modal content with focus trap ... */}
</div>
```

Consider using a headless dialog library (Radix, Headless UI) to get focus trapping and scroll lock for free.

---

### Q-11-2 HIGH: FeedFilter missing aria-pressed on active filter

**File:** `app/components/FeedFilter.tsx` — lines 60-73

**Description:** The active filter button has visual styling (bold text, colored underline) but no `aria-pressed` attribute. Screen readers announce all filter buttons identically.

**Impact:** Screen reader users cannot determine which feed filter is currently active. This fails WCAG 2.1 SC 4.1.2 (Name, Role, Value).

**Fix:**

```tsx
<button
  aria-pressed={currentFilter === filter.value}
  className={currentFilter === filter.value ? 'active-styles' : 'inactive-styles'}
  onClick={() => setFilter(filter.value)}
>
  {filter.label}
</button>
```

---

### Q-11-3 HIGH: Follow buttons missing aria-busy during loading

**Files:**
- `app/components/FollowUserButton.tsx` — line 56
- `app/components/FollowTagButton.tsx` — line 49

**Description:** Both follow buttons show "..." as loading text when a follow/unfollow action is pending. There is no `aria-busy` attribute, and the "..." text is announced literally by screen readers as "dot dot dot."

**Impact:** Screen reader users hear "dot dot dot" instead of understanding that an action is in progress. This fails WCAG 2.1 SC 4.1.3 (Status Messages).

**Fix:**

```tsx
<button
  aria-busy={isPending}
  disabled={isPending}
  onClick={handleFollow}
>
  {isPending ? <span aria-label="Loading">...</span> : isFollowing ? 'Unfollow' : 'Follow'}
</button>
```

---

### Q-11-4 MEDIUM: CollapsibleSection missing Space key activation

**File:** `app/components/CollapsibleSection.tsx` — line 32

**Description:** The collapsible header uses `role="button"` on a `<div>` and handles `onKeyDown` for the Enter key, but does not handle the Space key. ARIA specification requires that elements with `role="button"` respond to both Enter and Space.

**Impact:** Keyboard users who press Space on the collapsible header get no response, while Enter works. This is a partial keyboard failure — WCAG 2.1 SC 2.1.1 (Keyboard).

**Fix:**

```tsx
onKeyDown={(e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault()
    toggle()
  }
}}
```

---

### Q-11-5 MEDIUM: PostCard nested interactive elements inside Link

**File:** `app/components/PostCard.tsx` — lines 41, 115-116

**Description:** `CopyLinkButton` and `HidePostButton` are rendered as children of a Next.js `<Link>` component. This creates nested interactive elements (`<button>` inside `<a>`), which is invalid HTML per the specification.

**Impact:** Clicking these buttons also triggers the parent link navigation. Screen readers may announce the buttons incorrectly. This is invalid HTML and unpredictable behavior across browsers.

**Fix:** Restructure using the "card link" pattern — make the card a non-interactive container, overlay the main link with `::after` pseudo-element, and position the action buttons with higher z-index:

```tsx
<article className="relative">
  <Link href={`/post/${post.id}`} className="absolute inset-0 z-0" aria-label={postTitle} />
  <div className="relative z-10">
    {/* Post content */}
  </div>
  <div className="relative z-10" onClick={(e) => e.stopPropagation()}>
    <CopyLinkButton />
    <HidePostButton />
  </div>
</article>
```

---

### Q-11-6 MEDIUM: SatsInput hardcoded aria-label

**File:** `app/components/SatsInput.tsx` — line 100

**Description:** All instances of `SatsInput` share the same hardcoded `aria-label="Amount in sats"`. When multiple SatsInput components appear on the same page (e.g., tip form + lock form), screen readers cannot distinguish between them.

**Impact:** Screen reader users on pages with multiple sats inputs cannot tell which input is which. This fails WCAG 2.1 SC 1.3.1 (Info and Relationships).

**Fix:** Add a `label` prop to `SatsInput`:

```tsx
interface SatsInputProps {
  label?: string
  // ... other props
}

export function SatsInput({ label = 'Amount in sats', ...props }: SatsInputProps) {
  return <input aria-label={label} ... />
}
```

Then update call sites: `<SatsInput label="Tip amount in sats" />`, `<SatsInput label="Lock amount in sats" />`.

---

### Q-11-7 MEDIUM: LockForm no success confirmation

**File:** `app/components/LockForm.tsx` — lines 102-110

**Description:** After a successful lock operation, the form silently resets its fields. There is no success message, toast, or visual confirmation that the lock was created.

**Impact:** Users complete a financial operation (locking BSV) and receive no confirmation. They must check the locks list to verify it worked. This is poor UX for any financial action.

**Fix:**

```tsx
const [success, setSuccess] = useState(false)

// After successful lock:
setSuccess(true)
setTimeout(() => setSuccess(false), 5000)
resetForm()

// In JSX:
{success && (
  <div className="bg-[var(--accent)]/10 text-[var(--accent)] px-4 py-3 rounded" role="status">
    Lock created successfully!
  </div>
)}
```

---

### Q-11-8 MEDIUM: FeedClient "Refreshing..." shown on initial load

**File:** `app/components/FeedClient.tsx` — lines 94-98

**Description:** SWR's `isValidating` flag is true during both initial data fetching and background revalidation. The component shows a "Refreshing..." indicator whenever `isValidating` is true, which means it appears on every initial page load even when data loads from cache.

**Impact:** Users see a "Refreshing..." message on every page load, which is misleading when data is fresh. It creates a perception that the app is slow or constantly reloading.

**Fix:** Track whether the initial load has completed:

```tsx
const [hasInitiallyLoaded, setHasInitiallyLoaded] = useState(false)

useEffect(() => {
  if (data && !hasInitiallyLoaded) {
    setHasInitiallyLoaded(true)
  }
}, [data])

// Only show refreshing indicator after initial load
{hasInitiallyLoaded && isValidating && (
  <span className="text-sm text-[var(--muted)]">Refreshing...</span>
)}
```

---

### Q-11-9 LOW: Register page missing password-confirm validation

**File:** `app/(auth)/register/page.tsx`

**Description:** The registration form has both a password and confirm-password field, but there is no client-side validation that the two values match before form submission. Validation only occurs server-side.

**Impact:** Users who mistype their password confirmation must wait for a full round-trip to the server before learning about the mismatch. This is a minor UX friction point.

**Fix:** Add inline validation on the confirm-password field:

```tsx
const [passwordError, setPasswordError] = useState<string | null>(null)

<input
  type="password"
  onChange={(e) => {
    setConfirmPassword(e.target.value)
    setPasswordError(e.target.value !== password ? 'Passwords do not match' : null)
  }}
/>
{passwordError && <p className="text-[var(--danger)] text-sm">{passwordError}</p>}
```

---

### Q-11-10 LOW: MobileDrawer does not return focus on close

**File:** `app/components/MobileDrawer.tsx`

**Description:** When the mobile navigation drawer closes, focus is not returned to the trigger button that opened it. Focus falls to the document body.

**Impact:** Keyboard and screen reader users lose their place in the page after closing the drawer. They must Tab through the page to find where they were. This fails WCAG 2.1 SC 2.4.3 (Focus Order) best practices.

**Fix:** Store a ref to the trigger element and return focus on close:

```tsx
const triggerRef = useRef<HTMLButtonElement>(null)

// In the drawer open handler:
triggerRef.current = document.activeElement as HTMLButtonElement

// In the drawer close handler:
onClose()
triggerRef.current?.focus()
```

---

### Q-11-11 LOW: SearchBar and TagInput missing ARIA combobox pattern

**Files:**
- `app/components/SearchBar.tsx`
- `app/components/TagInput.tsx`

**Description:** Both components render autocomplete suggestion dropdowns but are missing the full ARIA combobox pattern:
- No `role="combobox"` on the input
- No `role="listbox"` on the dropdown
- No `role="option"` on individual suggestions
- No `aria-expanded` to indicate dropdown visibility
- No `aria-activedescendant` for keyboard navigation of options

**Impact:** Screen reader users cannot interact with the autocomplete functionality. The suggestions are invisible to assistive technology. This fails WCAG 2.1 SC 4.1.2 (Name, Role, Value).

**Fix:** Implement the full ARIA combobox pattern:

```tsx
<input
  role="combobox"
  aria-expanded={suggestions.length > 0}
  aria-controls="search-listbox"
  aria-activedescendant={activeIndex >= 0 ? `option-${activeIndex}` : undefined}
  aria-autocomplete="list"
/>
{suggestions.length > 0 && (
  <ul id="search-listbox" role="listbox">
    {suggestions.map((item, i) => (
      <li
        key={item.id}
        id={`option-${i}`}
        role="option"
        aria-selected={i === activeIndex}
      >
        {item.label}
      </li>
    ))}
  </ul>
)}
```

---

## Overall Assessment

**Rating: 8.0 / 10** — Down from the 9.5 achieved in Review #9. The functional correctness and security posture remain strong, but this deeper UX-focused pass reveals production-visible CSS bugs, a stability issue in the SWR layer, and significant accessibility gaps across the component library.

The codebase is solid engineering, but it does not yet meet production-quality UX standards for a public content-sharing platform. The three critical CSS variable bugs mean that success states, error states, and hover effects are invisible to users right now. The SWR retry bug creates server load spikes every time sessions expire. The accessibility gaps collectively exclude screen reader users from meaningful interaction with core features.

### Issue Summary

| Severity | Count | Examples |
|----------|-------|---------|
| Critical | 3 | B-11-1, B-11-2, B-11-3 (CSS variable bugs) |
| High | 7 | B-11-4 (SWR retry), B-11-5 (error swallowing), A-11-1 to A-11-4, Q-11-1 to Q-11-3 |
| Medium | 11 | B-11-7 to B-11-10, A-11-5, A-11-6, Q-11-4 to Q-11-8 |
| Low | 6 | Q-11-9, Q-11-10, Q-11-11 |
| **Total** | **27** | |

### Top 3 Priorities

1. **Fix the 3 critical CSS variable bugs (B-11-1, B-11-2, B-11-3)** — Elements are invisible in production right now. This is a 15-minute fix with immediate user-visible impact.

2. **Fix the SWR infinite retry bug (B-11-4)** — Causes server load spikes on session expiry and degrades the experience for all users with expired sessions. Requires a custom error class, retry handler fix, and SWRConfig provider.

3. **Add SEO metadata to dynamic routes (A-11-2)** — Critical for a content-sharing platform. Without Open Graph tags, shared links render with no preview on social media. Without page titles, search engine indexing is severely limited.

### Recommended Remediation Order

**Sprint 1 (immediate):** B-11-1, B-11-2, B-11-3, B-11-4, B-11-5
**Sprint 2 (this week):** A-11-1, A-11-2, Q-11-1, B-11-6, A-11-6
**Sprint 3 (next week):** A-11-3, A-11-4, Q-11-2, Q-11-3, Q-11-4, Q-11-5
**Sprint 4 (polish):** Remaining medium and low severity items
